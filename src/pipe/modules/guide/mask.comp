#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout( // input buffer rgba
set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input buffer rgba
set = 1, binding = 1
) uniform sampler2D ref_in;

layout( // local motion variation y
set = 1, binding = 2
) uniform sampler2D mot_in;

layout( // output gradients
set = 1, binding = 3
) uniform writeonly image2D mask_out;

float diff(vec3 a, vec3 b)
{
  return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z);
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(mask_out)))) return;

  vec3 m1 = texelFetch(img_in, ipos + ivec2(-1, -1), 0).rgb;
  vec3 m2 = texelFetch(img_in, ipos + ivec2(0, -1), 0).rgb;
  vec3 m3 = texelFetch(img_in, ipos + ivec2(1, -1), 0).rgb;
  vec3 m4 = texelFetch(img_in, ipos + ivec2(-1, 0), 0).rgb;
  vec3 m5 = texelFetch(img_in, ipos + ivec2(0, 0), 0).rgb;
  vec3 m6 = texelFetch(img_in, ipos + ivec2(1, 0), 0).rgb;
  vec3 m7 = texelFetch(img_in, ipos + ivec2(-1, 1), 0).rgb;
  vec3 m8 = texelFetch(img_in, ipos + ivec2(0, 1), 0).rgb;
  vec3 m9 = texelFetch(img_in, ipos + ivec2(1, 1), 0).rgb;

  vec3 mean = (m1 + m2 + m3 + m4 + m5 + m6 + m7 + m8 + m9) / 9;

  // local spatial variance
  float variance = 0;
  variance += diff(m1, mean) * diff(m1, mean);
  variance += diff(m2, mean) * diff(m2, mean);
  variance += diff(m3, mean) * diff(m3, mean);
  variance += diff(m4, mean) * diff(m4, mean);
  variance += diff(m5, mean) * diff(m5, mean);
  variance += diff(m6, mean) * diff(m6, mean);
  variance += diff(m7, mean) * diff(m7, mean);
  variance += diff(m8, mean) * diff(m8, mean);
  variance += diff(m9, mean) * diff(m9, mean);
  variance /= 9;

  // color difference
  vec3 r1 = texelFetch(ref_in, ipos + ivec2(-1, -1), 0).rgb;
  vec3 r2 = texelFetch(ref_in, ipos + ivec2(0, -1), 0).rgb;
  vec3 r3 = texelFetch(ref_in, ipos + ivec2(1, -1), 0).rgb;
  vec3 r4 = texelFetch(ref_in, ipos + ivec2(-1, 0), 0).rgb;
  vec3 r5 = texelFetch(ref_in, ipos + ivec2(0, 0), 0).rgb;
  vec3 r6 = texelFetch(ref_in, ipos + ivec2(1, 0), 0).rgb;
  vec3 r7 = texelFetch(ref_in, ipos + ivec2(-1, 1), 0).rgb;
  vec3 r8 = texelFetch(ref_in, ipos + ivec2(0, 1), 0).rgb;
  vec3 r9 = texelFetch(ref_in, ipos + ivec2(1, 1), 0).rgb;

  float coldiff = 0;
  coldiff += diff(r1, m1);
  coldiff += diff(r2, m2);
  coldiff += diff(r3, m3);
  coldiff += diff(r4, m4);
  coldiff += diff(r5, m5);
  coldiff += diff(r6, m6);
  coldiff += diff(r7, m7);
  coldiff += diff(r8, m8);
  coldiff += diff(r9, m9);
  coldiff /= 9;

  float d2 = coldiff * coldiff;

  float sigmd = 0.00001;
  variance = max(sigmd, variance);
  float dmd = 0;
  coldiff = coldiff * d2 / (d2 + dmd * dmd);
  d2 = coldiff * coldiff;
  float s = 2;
  float t = .20;

  // ======================================================
  // Local motion estimation
  float mot = texelFetch(mot_in, ipos, 0).r;
  if (mot > .2)
  {
    s = 12;
  }
  // ======================================================

  float R = clamp(s * exp(-d2 / variance) - t, 0, 1);
  //float R = clamp(1 * diff(m5, r5), 0, 1);

  imageStore(mask_out, ipos, vec4(R, R, R, R));
}
