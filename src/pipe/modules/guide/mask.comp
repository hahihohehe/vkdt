#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float dmd;
  float sigmd;
  float s;
  float t;
  float smot;
  float mth;
} params;

layout( // input buffer rgba
set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input buffer rgba
set = 1, binding = 1
) uniform sampler2D ref_in;

layout( // local motion variation y
set = 1, binding = 2
) uniform sampler2D mot_in;

layout( // output gradients
set = 1, binding = 3
) uniform writeonly image2D mask_out;

float hue(vec3 rgb)
{
  float m = min(rgb.r, min(rgb.b, rgb.g));
  float M = max(rgb.r, max(rgb.b, rgb.g));
  if (m == M)
  {
    return 0;
  }
  else if (M == rgb.r)
  {
    return 60 * (0 + (rgb.g - rgb.b) / (M - m));
  }
  else if (M == rgb.g)
  {
    return 60 * (2 + (rgb.b - rgb.r) / (M - m));
  }
  else if (M == rgb.b)
  {
    return 60 * (4 + (rgb.r - rgb.g) / (M - m));
  }
  return 0;
}

float diff(vec3 a, vec3 b)
{
  //return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z);
  return dot(10 * (a-b), 10 * (a-b));
  /*float hdiff = abs(hue(a) - hue(b));
  if (hdiff > 180)
  {
    hdiff = 360 - hdiff;
  }
  return hdiff / 180;*/
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(mask_out)))) return;

  vec3 m1 = texelFetch(img_in, ipos + ivec2(-1, -1), 0).rgb;
  vec3 m2 = texelFetch(img_in, ipos + ivec2(0, -1), 0).rgb;
  vec3 m3 = texelFetch(img_in, ipos + ivec2(1, -1), 0).rgb;
  vec3 m4 = texelFetch(img_in, ipos + ivec2(-1, 0), 0).rgb;
  vec3 m5 = texelFetch(img_in, ipos + ivec2(0, 0), 0).rgb;
  vec3 m6 = texelFetch(img_in, ipos + ivec2(1, 0), 0).rgb;
  vec3 m7 = texelFetch(img_in, ipos + ivec2(-1, 1), 0).rgb;
  vec3 m8 = texelFetch(img_in, ipos + ivec2(0, 1), 0).rgb;
  vec3 m9 = texelFetch(img_in, ipos + ivec2(1, 1), 0).rgb;

  // color difference
  vec3 r1 = texelFetch(ref_in, ipos + ivec2(-1, -1), 0).rgb;
  vec3 r2 = texelFetch(ref_in, ipos + ivec2(0, -1), 0).rgb;
  vec3 r3 = texelFetch(ref_in, ipos + ivec2(1, -1), 0).rgb;
  vec3 r4 = texelFetch(ref_in, ipos + ivec2(-1, 0), 0).rgb;
  vec3 r5 = texelFetch(ref_in, ipos + ivec2(0, 0), 0).rgb;
  vec3 r6 = texelFetch(ref_in, ipos + ivec2(1, 0), 0).rgb;
  vec3 r7 = texelFetch(ref_in, ipos + ivec2(-1, 1), 0).rgb;
  vec3 r8 = texelFetch(ref_in, ipos + ivec2(0, 1), 0).rgb;
  vec3 r9 = texelFetch(ref_in, ipos + ivec2(1, 1), 0).rgb;

  vec3 ref_mean = (r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9) / 9.0;
  vec3 cand_mean = (m1 + m2 + m3 + m4 + m5 + m6 + m7 + m8 + m9) / 9.0;


  // local spatial variance
  float r_var = 0;
  r_var += diff(r1, ref_mean) * diff(r1, ref_mean);
  r_var += diff(r2, ref_mean) * diff(r2, ref_mean);
  r_var += diff(r3, ref_mean) * diff(r3, ref_mean);
  r_var += diff(r4, ref_mean) * diff(r4, ref_mean);
  r_var += diff(r5, ref_mean) * diff(r5, ref_mean);
  r_var += diff(r6, ref_mean) * diff(r6, ref_mean);
  r_var += diff(r7, ref_mean) * diff(r7, ref_mean);
  r_var += diff(r8, ref_mean) * diff(r8, ref_mean);
  r_var += diff(r9, ref_mean) * diff(r9, ref_mean);
  r_var /= 9;

  float m_var = 0;
  m_var += diff(m1, cand_mean) * diff(m1, cand_mean);
  m_var += diff(m2, cand_mean) * diff(m2, cand_mean);
  m_var += diff(m3, cand_mean) * diff(m3, cand_mean);
  m_var += diff(m4, cand_mean) * diff(m4, cand_mean);
  m_var += diff(m5, cand_mean) * diff(m5, cand_mean);
  m_var += diff(m6, cand_mean) * diff(m6, cand_mean);
  m_var += diff(m7, cand_mean) * diff(m7, cand_mean);
  m_var += diff(m8, cand_mean) * diff(m8, cand_mean);
  m_var += diff(m9, cand_mean) * diff(m9, cand_mean);
  m_var /= 9;

  //float variance = min(r_var, m_var);
  float variance = m_var;

  float coldiff = 0;
  coldiff += diff(r1, m1);
  coldiff += diff(r2, m2);
  coldiff += diff(r3, m3);
  coldiff += diff(r4, m4);
  coldiff += diff(r5, m5);
  coldiff += diff(r6, m6);
  coldiff += diff(r7, m7);
  coldiff += diff(r8, m8);
  coldiff += diff(r9, m9);
  coldiff /= 9;


  //float coldiff = diff(ref_mean, cand_mean);


  // float R = 1 - coldiff;

  float d2 = coldiff * coldiff;

  float sigmd = params.sigmd;
  variance = max(sigmd, variance);
  //variance = 1;
  float dmd = params.dmd;
  coldiff = coldiff * d2 / (d2 + dmd * dmd);
  d2 = coldiff * coldiff;
  float s = params.s;
  float t = params.t;

  // ======================================================
  // Local motion estimation
  float mot = texelFetch(mot_in, ipos, 0).r;
  if (mot > params.mth)
  {
    s = params.smot;
  }
  // ======================================================

  //float R = clamp(100 * variance, 0, 1);
  //float R = clamp(d2 / variance, 0, 1);
  float R = clamp(s * exp(-d2 / variance) - t, 0, 1);
  // float R = clamp(coldiff, 0, 1);
  //float R = clamp(1 * diff(m5, r5), 0, 1);

  imageStore(mask_out, ipos, vec4(R, R, R, R));
}
