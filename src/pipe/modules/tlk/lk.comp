#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "config.h"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout( // input buffer rggb / rgba
set = 1, binding = 0
) uniform sampler2D F_in;

layout( // input buffer rggb / rgba
set = 1, binding = 1
) uniform sampler2D G_in;

layout( // motion vectors rg / tiles resolution
set = 1, binding = 2
) uniform sampler2D off_in;

layout( // output motion vectors / tiles resolution
set = 1, binding = 3
) uniform writeonly image2D off_out;

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(off_out)))) return;

  vec2 h_k = texelFetch(off_in, ipos, 0).xy;

  vec2 change = vec2(0, 0);
  float divisor = 0;

  {
    for (int i = 0; i <= TILE_SIZE; i++)
    {
      for (int j = 0; j <= TILE_SIZE; j++)
      {
        ivec2 displ = ivec2(i, j);
        float G = texelFetch(G_in, (TILE_SIZE / 2 * ipos) + displ, 0).r;
        float F = texture(F_in, ((TILE_SIZE / 2 * ipos) + displ + vec2(.5, .5) + h_k) / textureSize(F_in, 0)).r;

        // middle of 9 x 9 block
        ivec2 mid_pos = ivec2(vec2(.5, .5) + (TILE_SIZE / 2 * ipos) + displ + h_k);

        // strategy for calculating I_F needs to be replaced for bayer mosaic
        /*float F_1 = texelFetch(F_in, mid_pos + ivec2(-1, -1), 0).r;
        float F_2 = texelFetch(F_in, mid_pos + ivec2(0, -1), 0).r;
        float F_3 = texelFetch(F_in, mid_pos + ivec2(1, -1), 0).r;
        float F_4 = texelFetch(F_in, mid_pos + ivec2(-1, 0), 0).r;
        float F_5 = texelFetch(F_in, mid_pos + ivec2(0, 0), 0).r;
        float F_6 = texelFetch(F_in, mid_pos + ivec2(1, 0), 0).r;
        float F_7 = texelFetch(F_in, mid_pos + ivec2(-1, 1), 0).r;
        float F_8 = texelFetch(F_in, mid_pos + ivec2(0, 1), 0).r;
        float F_9 = texelFetch(F_in, mid_pos + ivec2(1, 1), 0).r;

        float v_1 = F_1 - F_7;
        float v_2 = F_2 - F_8;
        float v_3 = F_3 - F_9;
        float h_1 = F_1 - F_3;
        float h_2 = F_4 - F_6;
        float h_3 = F_7 - F_9;

        vec2 sub = vec2(ivec2(vec2(ipos + displ) + h_k)) - (vec2(ipos + displ) + h_k);

        vec2 I_F = vec2(h_2 + mix(h_3, h_1, sub.y), v_2 + mix(v_3, v_1, sub.x));
        I_F /= 4;
        I_F *= vec2(-1, -1);}/

        // debugging stategy
        /*float F_1 = texelFetch(F_in, mid_pos + ivec2(-1, -1), 0).r;
        float F_2 = texelFetch(F_in, mid_pos + ivec2(0, -1), 0).r;
        float F_3 = texelFetch(F_in, mid_pos + ivec2(1, -1), 0).r;
        float F_4 = texelFetch(F_in, mid_pos + ivec2(-1, 0), 0).r;
        float F_5 = texelFetch(F_in, mid_pos + ivec2(0, 0), 0).r;
        float F_6 = texelFetch(F_in, mid_pos + ivec2(1, 0), 0).r;
        float F_7 = texelFetch(F_in, mid_pos + ivec2(-1, 1), 0).r;
        float F_8 = texelFetch(F_in, mid_pos + ivec2(0, 1), 0).r;
        float F_9 = texelFetch(F_in, mid_pos + ivec2(1, 1), 0).r;

        float v_1 = F_1 - F_7;
        float v_2 = F_2 - F_8;
        float v_3 = F_3 - F_9;
        float h_1 = F_1 - F_3;
        float h_2 = F_4 - F_6;
        float h_3 = F_7 - F_9;

        vec2 sub = vec2(ivec2(vec2(ipos + displ) + h_k)) - (vec2(ipos + displ) + h_k);

        // vec2 I_F = vec2(h_2, v_2);
        vec2 I_F = vec2(h_2 + .5 * h_3 + .5 * h_1, v_2 + .5 * v_3 + .5 * v_1);
        I_F /= 4;
        I_F *= vec2(-1, -1);*/

        // alternative strategy
        /*float F_1 = texelFetch(F_in, mid_pos + ivec2(0, 1), 0).r;
        float F_2 = texelFetch(F_in, mid_pos + ivec2(1, 0), 0).r;
        float F_3 = texelFetch(F_in, mid_pos + ivec2(0, -1), 0).r;
        float F_4 = texelFetch(F_in, mid_pos + ivec2(-1, 0), 0).r;

        vec2 I_F = .5 * vec2(F_2 - F_4, F_1 - F_3);
        I_F *= vec2(1, 1);*/

        // smaller
        mid_pos = ivec2((TILE_SIZE / 2 * ipos) + displ + h_k);
        float F_1 = texelFetch(F_in, mid_pos + ivec2(0, 1), 0).r;
        float F_2 = texelFetch(F_in, mid_pos + ivec2(1, 0), 0).r;
        float F_3 = texelFetch(F_in, mid_pos + ivec2(0, 0), 0).r;
        float F_4 = texelFetch(F_in, mid_pos + ivec2(1, 1), 0).r;

        vec2 I_F = .5 * vec2(F_2 + F_4 - F_1 - F_3, F_1 + F_4 - F_2 - F_3);
        I_F *= vec2(1, 1);

        vec2 diff = I_F * (G - F);

        change += I_F * (G - F);
        // divisor += clamp(dot(I_F, I_F), .5, 20);   // lower bound is to prevent huge steps
        divisor += dot(I_F, I_F);
      }
    }
  }

  if (true || divisor > 0)
  {
    change /= divisor;
  }
  else  // prefer no change if divisor is 0, otherwise the shift would be huge
  {
    change = vec2(0, 0);
  }

  //change *= .3;
  //change = clamp(change, -1, 1);
  // change = clamp(change, -.5, .5);
  // change *= .3;

  vec2 h_k1 = h_k + 1 * change;

  imageStore(off_out, ipos, vec4(h_k1, h_k1));
}
