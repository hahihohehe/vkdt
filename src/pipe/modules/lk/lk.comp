#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "config.h"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout( // input buffer rggb / rgba
set = 1, binding = 0
) uniform sampler2D F_in;

layout( // input buffer rggb / rgba
set = 1, binding = 1
) uniform sampler2D G_in;

layout( // motion vectors rg
set = 1, binding = 2
) uniform sampler2D off_in;

layout( // output motion vectors
set = 1, binding = 3
) uniform writeonly image2D off_out;

#define PATCH_RAD 0

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(off_out)))) return;

  vec2 h_k = texelFetch(off_in, ipos, 0).xy;

  vec2 change = vec2(0, 0);
  float divisor = 0;

  {
    for (int i = -PATCH_RAD; i <= PATCH_RAD; i++)
    {
      for (int j = -PATCH_RAD; j <= PATCH_RAD; j++)
      {
        ivec2 displ = ivec2(i, j);
        float G = texelFetch(G_in, ipos + displ, 0).r;
        float F = texture(F_in, (ipos + displ + vec2(.5, .5) + h_k) / textureSize(F_in, 0)).r;

        // middle of 9 x 9 block
        ivec2 mid_pos = ivec2(vec2(.5, .5) + ipos + displ + h_k);

        // strategy for calculating I_F needs to be replaced for bayer mosaic
        /*float F_1 = lum(texelFetch(F_in, mid_pos + ivec2(-1, -1), 0).rgb);
        float F_2 = lum(texelFetch(F_in, mid_pos + ivec2(0, -1), 0).rgb);
        float F_3 = lum(texelFetch(F_in, mid_pos + ivec2(1, -1), 0).rgb);
        float F_4 = lum(texelFetch(F_in, mid_pos + ivec2(0, -1), 0).rgb);
        float F_5 = lum(texelFetch(F_in, mid_pos + ivec2(0, 0), 0).rgb);
        float F_6 = lum(texelFetch(F_in, mid_pos + ivec2(0, 1), 0).rgb);
        float F_7 = lum(texelFetch(F_in, mid_pos + ivec2(1, -1), 0).rgb);
        float F_8 = lum(texelFetch(F_in, mid_pos + ivec2(1, 0), 0).rgb);
        float F_9 = lum(texelFetch(F_in, mid_pos + ivec2(1, 1), 0).rgb);

        float v_1 = F_1 - F_7;
        float v_2 = F_2 - F_8;
        float v_3 = F_3 - F_9;
        float h_1 = F_1 - F_3;
        float h_2 = F_4 - F_6;
        float h_3 = F_7 - F_9;

        vec2 sub = vec2(ivec2(vec2(ipos + displ) + h_k)) - (vec2(ipos + displ) + h_k);

        vec2 I_F = vec2(h_2 + mix(h_3, h_1, sub.y), v_2 + mix(v_3, v_1, sub.x));
        I_F /= 2;*/

        // alternative strategy
        float F_1 = texelFetch(F_in, mid_pos + ivec2(0, 1), 0).r;
        float F_2 = texelFetch(F_in, mid_pos + ivec2(1, 0), 0).r;
        float F_3 = texelFetch(F_in, mid_pos + ivec2(0, -1), 0).r;
        float F_4 = texelFetch(F_in, mid_pos + ivec2(-1, 0), 0).r;

        vec2 I_F = .5 * vec2(F_2 - F_4, F_1 - F_3);


        I_F *= vec2(1, 1);

        vec2 diff = I_F * (G - F);

        change += I_F * (G - F);
        // divisor += clamp(dot(I_F, I_F), .5, 20);   // lower bound is to prevent huge steps
        divisor += dot(I_F, I_F);
      }
    }
  }

  if (divisor > 0)
  {
    change /= divisor;
  }
  else  // prefer no change if divisor is 0, otherwise the shift would be huge
  {
    change = vec2(0, 0);
  }

  change = clamp(change, -1, 1);
  // change *= .3;

  vec2 h_k1 = h_k + 1 * change;

  imageStore(off_out, ipos, vec4(h_k1, h_k1));
}
