#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint filters;
  int  scale;
} push;

layout( // input buffer
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input buffer warp offsets
    set = 1, binding = 1
) uniform sampler2D img_off;

layout( // output buffer
    set = 1, binding = 2
) uniform writeonly image2D img_out;

layout( // output debug visualisation of mv
    set = 1, binding = 3
) uniform writeonly image2D img_visn;

layout( // output motion vectors for other modules
    set = 1, binding = 4
) uniform writeonly image2D img_mv;

// runs on output dimensions, reads offset texture
// and input image at offset position, rounded to mosaic block.
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  int block = push.scale;
  // offset is on coarse scale (/block):
  vec2 off = block * textureLod(img_off, (ipos+.5)/vec2(block*textureSize(img_off, 0)), 0).rg;
  // vec2 off = block * sample_soft(img_off, (ipos+.5)/vec2(block*textureSize(img_off, 0))).rg;

  vec3 col;
  if(push.filters == 0)
  { // no mosaic: just grab pixel regardless of mosaic
    // col = texture(img_in, (vec2(ipos)+0.5 + off.rg)/vec2(textureSize(img_in, 0))).rgb; // soft
    // col = sample_catmull_rom(img_in, (vec2(ipos)+0.0 + off.rg)/vec2(textureSize(img_in, 0))).rgb; // sharper
    col = texelFetch(img_in, ipos + ivec2(off.rg), 0).rgb; // sharpest
  }
  else
  { // bayer: stupid hack #1 to keep mosaic pattern: round off to block size:
    ivec2 offi = ivec2(off.rg / (block));
    offi = block * offi;
    col = texelFetch(img_in, ipos + offi, 0).rrr;
  }

  { // fill debug normals
    // float len = length(off.xy);
    // vec3 rgb = vec3(0.0);
    // if(len > 2.0) rgb = vec3(off.xy/max(10.0, len), 0);
    vec3 rgb = vec3(off.xy, 0) * 0.05;
    rgb = clamp((vec3(1.0) + rgb)*.5, vec3(0.0), vec3(1.0));
    imageStore(img_visn, ipos, vec4(rgb, 1));

  }

  // pass on rescaled motion vectors for output
  imageStore(img_mv, ipos, off.xyxy);

  imageStore(img_out, ipos, vec4(col, 1));
}
