#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint filters;
  uint i;
} push;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 1) uniform params_t
{
  float cert;
  float inc;
  float sup;
  float rot;
  float ani;
  float mask;
  float off;
  int image;
  float k_det;
  float k_den;
  float k_stret;
  float k_shri;
  float d_th;
  float d_tr;
  int gauss;
} params;

layout( // input rggb original
    set = 1, binding = 0
) uniform sampler2D img;

layout( // input offsets
set = 1, binding = 1
) uniform sampler2D off;

layout( // input mask
set = 1, binding = 2
) uniform sampler2D mask_in;

layout( // input accumulation buffer
set = 1, binding = 3
) uniform sampler2D acc_in;

layout( // input weights
set = 1, binding = 4
) uniform sampler2D cont_in;

layout( // gradients
set = 1, binding = 5
) uniform sampler2D grad_in;

layout( // output f16 rgb accumulation buffer
    set = 1, binding = 6
) uniform writeonly image2D acc_out;

layout( // output f16 rgb weights
set = 1, binding = 7
) uniform writeonly image2D cont_out;

#define M_PI 3.14159265358979

// mostly copied from align/splat
void
eval_gauss(
vec4 cov, vec2 off,
out float weight)
{
  dvec2 eval = clamp(cov.xy, 0.01, 25); // the lower bound has direct impact on sharpness
  dmat2 E = dmat2(cov.z, -cov.w,
                cov.w,  cov.z);
  dvec2 of = E * off;
  weight = clamp(exp(float(-0.5*dot(of/eval, of))), 1e-4, 1);
}

void grad_proc(
    vec2 grad,
    vec2 off,
    out float weight)
{
  mat2 O = mat2(grad.x * grad.x, grad.x * grad.y,
                grad.x * grad.y, grad.y * grad.y);
  vec2 eval;
  vec2 evec0;
  vec2 evec1;
  evd2x2(eval, evec0, evec1, O);

  // test values:
  /*eval = vec2(4, 1);
  evec0 = vec2(1, 0);
  evec1 = vec2(0, -1);*/

  float l1 = eval.x;
  float l2 = eval.y;

  if (l2 > l1)
  { // swap
    l1 = eval.y;
    l2 = eval.x;
    vec2 tmp = evec0;
    evec0 = evec1;
    evec1 = tmp;
  }

  // configuration parameters
  /*float k_detail = 0.2;
  float k_denoise = 3;
  float k_stretch = 4;
  float k_shrink = 2;*/
  float k_detail = params.k_det;
  float k_denoise = params.k_den;
  float k_stretch = params.k_stret;
  float k_shrink = params.k_shri;
  float D_th = params.d_th;
  float D_tr = params.d_tr;

  float A = clamp(1 + sqrt(l1 / l2), 1, 10);
  float D = clamp(1 - sqrt(l1) / D_tr + D_th, 0, 1);
  // D = 0;
  float k1_ = k_detail * k_stretch * A;
  float k2_ = k_detail / (k_shrink * A);
  float k1 = ((1 - D) * k1_ + D * k_detail * k_denoise);
  k1 *= k1;
  float k2 = ((1 - D) * k2_ + D * k_detail * k_denoise);
  k2 *= k2;

  vec2 of = vec2(dot(off, evec0), dot(off, evec1));
  weight = clamp(exp(-0.5*dot(of/vec2(k1, k2), of)), 1e-4, 1);
}

vec4
color_vec(    // get a normalized vector with one of r, g, b being 1, all other entries 0 according to bayer mosaic
ivec2 ipos
)
{
  ivec2 boff = ivec2(ipos.x%2, ipos.y%2);// offset inside block
  if (boff == ivec2(1, 0))
  { // green
    return vec4(0, 1, 0, 0);
  }
  else if (boff == ivec2(0, 1))
  { // green
    return vec4(0, 1, 0, 0);
  }
  else if (boff == ivec2(0, 0))
  { // red
    return vec4(1, 0, 0, 0);
  }
  else
  { // blue
    return vec4(0, 0, 1, 0);
  }
}

#define SSIZE 1  // sample size: sampling box has dimensions 2*SSIZE+1 x 2*SSIZE+1

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(acc_out)))) return;

  float res = params.inc + 1.0;

  // vec2 o = 2 * textureLod(off, (ipos+.5)/vec2(2*textureSize(off, 0)), 0).rg;   // should actually be rescaled in align/warp
  // vec2 epos = ipos + push.offset_scale * 0.1 * texelFetch(off, ipos, 0).xy;   // effective position
  vec2 epos = vec2(ipos) / res;   // effective position
  ivec2 spos = ivec2(epos + vec2(.5, .5));

  if (params.gauss <= 0)
    epos += params.off * texelFetch(off, spos, 0).xy;
  // vec2 epos = ipos + o;
  // vec2 epos = ipos;

  // TODO: support rgb and xtrans input
  vec4 acc_old = texelFetch(acc_in, ipos, 0);
  vec4 wsum_old = texelFetch(cont_in, ipos, 0);

  vec4 acc = vec4(0, 0, 0, 0);
  vec4 wsum = vec4(0, 0, 0, 0);

  float mask;
  if (push.filters == 0)
    mask = texelFetch(mask_in, spos/4, 0).r;
  else
    mask = texelFetch(mask_in, spos/2, 0).r;

  if (push.i == params.image || params.image == -1)
  {
    if (mask < params.cert)
    {
      for (int i = -SSIZE; i <= SSIZE; i++)
      {
        for (int j = -SSIZE; j <= SSIZE; j++)
        {
          // TODO: include mask and gradients
          float weight;
          float phi = M_PI * params.rot;
          float afac = 1 - params.ani;
          vec4 cov = vec4(params.sup / afac, params.sup * afac, cos(phi), sin(phi));// needs to be replaced according to estimated gradients
          ivec2 sourcepos = ivec2(epos + vec2(.5, .5)) + ivec2(i, j);// position of sample
          vec2 actualsourcepos = epos + vec2(i, j);// fp position of source pixel
          if (any(greaterThanEqual(sourcepos, textureSize(img, 0)))) continue;
          if (any(lessThan(sourcepos, ivec2(0, 0)))) continue;

          vec2 grad = texelFetch(grad_in, sourcepos, 0).xy;

          vec2 sub = epos - vec2(ivec2(epos + vec2(.5, .5)));
          if (params.sup > 0){
            eval_gauss(cov, sub - vec2(i, j), weight);
          } else {
            grad_proc(grad, vec2(i, j) - sub, weight);
          }

          if (params.gauss > 0)
          {
            if (sourcepos.x % 10 == 0 && sourcepos.y % 10 == 0)
            acc += weight * vec4(1, 1, 1, 0);
            wsum += 1 * vec4(1, 1, 1, 0);
          }
          else
          {
            if (push.filters == 0)
            {
              // Debug gaussians
              // if (sourcepos.x % 10 == 0 && sourcepos.y % 10 == 0)
              acc += weight * texelFetch(img, sourcepos, 0);
              wsum += weight * vec4(1, 1, 1, 0);
            }
            else {
              float intensity = texelFetch(img, sourcepos, 0).r;

              // Debug gaussians
              // if (sourcepos.x % 10 == 0 && sourcepos.y % 10 == 0)

              acc += weight * intensity * color_vec(sourcepos);
              wsum += weight * color_vec(sourcepos);
            }
          }
        }
      }
    }
    // wsum += vec4(.1, .1, .1, 0);
    // acc = vec4(mask, mask, mask, 1);
    // wsum = vec4(1, 1, 1, 1);
  }

  // acc = .2 * vec4(mask, mask, mask, 5);
  // wsum = vec4(1, 1, 1, 1);


  imageStore(acc_out, ipos, acc + acc_old);
  imageStore(cont_out, ipos, wsum + wsum_old);
  // imageStore(acc_out, ipos, acc_old);
  // imageStore(cont_out, ipos, wsum_old);
  // imageStore(acc_out, ipos, acc);
  // imageStore(cont_out, ipos, wsum);
}
