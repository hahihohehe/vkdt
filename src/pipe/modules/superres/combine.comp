#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint filters;
} push;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 1) uniform params_t
{
  float cert;
} params;

layout( // input rggb original
    set = 1, binding = 0
) uniform sampler2D img;

layout( // input offsets
set = 1, binding = 1
) uniform sampler2D off;

layout( // input mask
set = 1, binding = 2
) uniform sampler2D mask;

layout( // input accumulation buffer
set = 1, binding = 3
) uniform sampler2D acc_in;

layout( // input weights
set = 1, binding = 4
) uniform sampler2D cont_in;

/*layout( // gradients
set = 1, binding = 5
) uniform sampler2D grad;*/

layout( // output f16 rgb accumulation buffer
    set = 1, binding = 5
) uniform writeonly image2D acc_out;

layout( // output f16 rgb weights
set = 1, binding = 6
) uniform writeonly image2D cont_out;

// mostly copied from align/splat
void
eval_gauss(
vec4 cov, vec2 off,
out float weight)
{
  vec2 eval = clamp(cov.xy, 0.01, 25); // the lower bound has direct impact on sharpness
  mat2 E = mat2(cov.z, -cov.w,
                cov.w,  cov.z);
  vec2 of = E * off;
  weight = clamp(exp(-0.5*dot(of/eval, of)), 1e-4, 1.0);
}

vec4
color_vec(    // get a normalized vector with one of r, g, b being 1, all other entries 0 according to bayer mosaic
ivec2 ipos
)
{
  ivec2 boff = ivec2(ipos.x%2, ipos.y%2);   // offset inside block
  if (boff == ivec2(1, 0))
  {   // green
    return vec4(0, 1, 0, 0);
  }
  else if (boff == ivec2(0, 1))
  {   // green
    return vec4(0, 1, 0, 0);
  }
  else if (boff == ivec2(0, 0))
  {   // red
    return vec4(1, 0, 0, 0);
  }
  else
  {   // blue
    return vec4(0, 0, 1, 0);
  }
}

#define SSIZE 2

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(acc_out)))) return;

  // vec2 o = 2 * textureLod(off, (ipos+.5)/vec2(2*textureSize(off, 0)), 0).rg;   // should actually be rescaled in align/warp
  // vec2 epos = ipos + push.offset_scale * 0.1 * texelFetch(off, ipos, 0).xy;   // effective position
  vec2 epos = ipos + texelFetch(off, ipos, 0).xy;   // effective position
  // vec2 epos = ipos + o;
  // vec2 epos = ipos;
  ivec2 scent = ivec2(epos);    // sample center: sample around epos rounded down

  // TODO: support rgb and xtrans input
  vec4 acc_old = texelFetch(acc_in, ipos, 0);
  vec4 wsum_old = texelFetch(cont_in, ipos, 0);

  vec4 acc = vec4(0, 0, 0, 0);
  vec4 wsum = vec4(0, 0, 0, 0);

  float mask = texelFetch(mask, ipos / 2, 0).r;
  if (mask < params.cert)
  {
    for (int i = -SSIZE; i <= SSIZE; i++)
    {
      for (int j = -SSIZE; j <= SSIZE; j++)
      {
        // TODO: include mask and gradients
        float weight;
        vec4 cov = vec4(1, 1, 1, 0);// needs to be replaced according to estimated gradients
        ivec2 sourcepos = scent + ivec2(i, j);// position of sample
        vec2 actualsourcepos = epos + ivec2(i, j);// fp position of source pixel
        if (any(greaterThanEqual(sourcepos, imageSize(acc_out)))) continue;
        if (any(lessThan(sourcepos, ivec2(0, 0)))) continue;
        eval_gauss(cov, actualsourcepos - scent, weight);
        float intensity = texelFetch(img, sourcepos, 0).r;
        // acc += weight * intensity * color_vec(sourcepos);
        // wsum += 0.1 * weight * color_vec(sourcepos);
        acc += weight * intensity * color_vec(sourcepos);
        // acc += vec4(1, 0, 0, 0);
        // wsum += vec4(1, 0, 0, 0);
        wsum += weight * color_vec(sourcepos);
      }
    }
    // wsum += vec4(.1, .1, .1, 0);
    // acc = vec4(mask, mask, mask, 1);
    // wsum = vec4(1, 1, 1, 1);
  }

  // acc = .2 * vec4(mask, mask, mask, 5);
  // wsum = vec4(1, 1, 1, 1);


  imageStore(acc_out, ipos, acc + acc_old);
  imageStore(cont_out, ipos, wsum + wsum_old);
  // imageStore(acc_out, ipos, acc_old);
  // imageStore(cont_out, ipos, wsum_old);
  // imageStore(acc_out, ipos, acc);
  // imageStore(cont_out, ipos, wsum);
}
