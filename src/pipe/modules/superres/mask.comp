#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint block;
} push;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float cert;
  float inc;
  float sup;
  float rot;
  float ani;
  float mask;
  float off;
  int image;
  float k_det;
  float k_den;
  float k_stret;
  float k_shri;
  float d_th;
  float d_tr;
  int gauss;
  int pointc;
  float dmd;
  float sigmd;
  float s;
  float t;
} params;

layout( // input buffer rgba
set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input buffer rgba
set = 1, binding = 1
) uniform sampler2D ref_in;

layout( // output gradients
set = 1, binding = 2
) uniform writeonly image2D mask_out;

float diff(vec3 a, vec3 b)
{
  return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z);
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(mask_out)))) return;


  vec3 m1 = texelFetch(img_in, ipos + ivec2(-1, -1), 0).rgb;
  vec3 m2 = texelFetch(img_in, ipos + ivec2(0, -1), 0).rgb;
  vec3 m3 = texelFetch(img_in, ipos + ivec2(1, -1), 0).rgb;
  vec3 m4 = texelFetch(img_in, ipos + ivec2(-1, 0), 0).rgb;
  vec3 m5 = texelFetch(img_in, ipos + ivec2(0, 0), 0).rgb;
  vec3 m6 = texelFetch(img_in, ipos + ivec2(1, 0), 0).rgb;
  vec3 m7 = texelFetch(img_in, ipos + ivec2(-1, 1), 0).rgb;
  vec3 m8 = texelFetch(img_in, ipos + ivec2(0, 1), 0).rgb;
  vec3 m9 = texelFetch(img_in, ipos + ivec2(1, 1), 0).rgb;

  vec3 mean = (m1 + m2 + m3 + m4 + m5 + m6 + m7 + m8 + m9) / 9;

  // local spatial variance
  float variance = 0;
  variance += diff(m1, mean) * diff(m1, mean);
  variance += diff(m2, mean) * diff(m2, mean);
  variance += diff(m3, mean) * diff(m3, mean);
  variance += diff(m4, mean) * diff(m4, mean);
  variance += diff(m5, mean) * diff(m5, mean);
  variance += diff(m6, mean) * diff(m6, mean);
  variance += diff(m7, mean) * diff(m7, mean);
  variance += diff(m8, mean) * diff(m8, mean);
  variance += diff(m9, mean) * diff(m9, mean);
  variance /= 9;

  // color difference
  vec3 r1 = texelFetch(img_in, ipos + ivec2(-1, -1), 0).rgb;
  vec3 r2 = texelFetch(img_in, ipos + ivec2(0, -1), 0).rgb;
  vec3 r3 = texelFetch(img_in, ipos + ivec2(1, -1), 0).rgb;
  vec3 r4 = texelFetch(img_in, ipos + ivec2(-1, 0), 0).rgb;
  vec3 r5 = texelFetch(img_in, ipos + ivec2(0, 0), 0).rgb;
  vec3 r6 = texelFetch(img_in, ipos + ivec2(1, 0), 0).rgb;
  vec3 r7 = texelFetch(img_in, ipos + ivec2(-1, 1), 0).rgb;
  vec3 r8 = texelFetch(img_in, ipos + ivec2(0, 1), 0).rgb;
  vec3 r9 = texelFetch(img_in, ipos + ivec2(1, 1), 0).rgb;

  float coldiff = 0;
  coldiff += diff(r1, m1);
  coldiff += diff(r2, m2);
  coldiff += diff(r3, m3);
  coldiff += diff(r4, m4);
  coldiff += diff(r5, m5);
  coldiff += diff(r6, m6);
  coldiff += diff(r7, m7);
  coldiff += diff(r8, m8);
  coldiff += diff(r9, m9);
  coldiff /= 9;

  float d2 = coldiff * coldiff;

  variance = max(params.sigmd, variance);
  coldiff = coldiff * d2 / (d2 + params.dmd * params.dmd);

  float R = params.s * exp(-coldiff * coldiff / variance) - params.t;

  imageStore(mask_out, ipos, vec4(variance));
}
