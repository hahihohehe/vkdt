#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

/*
 * We warp the image and do a block-based demosaic at the same time for robustness calculations
 */

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint block;
  uint i;
} push;

layout( // input buffer rggb / rgba
set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input buffer xy
set = 1, binding = 1
) uniform sampler2D off_in;

layout( // output gradients
set = 1, binding = 2
) uniform writeonly image2D guide_out;

float diff(vec3 a, vec3 b)
{
  return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z);
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(guide_out)))) return;

  ivec2 off = ivec2(0, 0);
  if (push.i != 0)
  {
    vec2 mv = texelFetch(off_in, 2 * ipos, 0).xy;
    off = ivec2(mv + .5);
  }

  vec3 col = vec3(0, 0, 0);

  if (push.block < 2)
  {
    col = texelFetch(img_in, ipos + off, 0).rgb;
  }
  else  // assume bayer
  {
    ivec2 blockpos = 2 * (ivec2(2 * ipos + off) / 2);
    float m1 = texelFetch(img_in, blockpos + ivec2(0, 0), 0).r;
    float m2 = texelFetch(img_in, blockpos + ivec2(0, 1), 0).r;
    float m3 = texelFetch(img_in, blockpos + ivec2(1, 0), 0).r;
    float m4 = texelFetch(img_in, blockpos + ivec2(1, 1), 0).r;
    col = vec3(.5 * m1 + .5 * m3, m2, m4);
  }

  imageStore(guide_out, ipos, vec4(col, 1));
}
