#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint filters;
} push;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 1) uniform params_t
{
  float cert;
  float inc;
  float sup;
  float rot;
  float ani;
  float mask;
} params;

layout( // input rggb original
    set = 1, binding = 0
) uniform sampler2D img;

/*layout( // gradients
set = 1, binding = 1
) uniform sampler2D grad;*/

layout( // output f16 rgb accumulation buffer
    set = 1, binding = 1
) uniform writeonly image2D acc_out;

layout( // output f16 rgb weights
set = 1, binding = 2
) uniform writeonly image2D cont_out;

#define M_PI 3.14159265358979

// mostly copied from align/splat
void
eval_gauss(
vec4 cov, vec2 off,
out float weight)
{
  vec2 eval = clamp(cov.xy, 0.01, 25); // the lower bound has direct impact on sharpness
  mat2 E = mat2(cov.z, -cov.w,
                cov.w,  cov.z);
  vec2 of = E * off;
  weight = clamp(exp(-0.5*dot(of/eval, of)), 1e-4, 1.0);
}

vec4
color_vec(    // get a normalized vector with one of r, g, b being 1, all other entries 0 according to bayer mosaic
ivec2 ipos
)
{
  ivec2 boff = ivec2(ipos.x%2, ipos.y%2);   // offset inside block
  if (boff == ivec2(1, 0))
  {   // green
    return vec4(0, 1, 0, 0);
  }
  else if (boff == ivec2(0, 1))
  {   // green
    return vec4(0, 1, 0, 0);
  }
  else if (boff == ivec2(0, 0))
  {   // red
    return vec4(1, 0, 0, 0);
  }
  else
  {   // blue
    return vec4(0, 0, 1, 0);
  }
}

#define SSIZE 2

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(acc_out)))) return;
  float res = params.inc + 1.0;

  vec2 epos = vec2(ipos) / res;


  // TODO: support rgb and xtrans input
  vec4 acc = vec4(0, 0, 0, 1);  // because first image
  vec4 wsum = vec4(0, 0, 0, 1);
  for (int i = -SSIZE; i <= SSIZE; i++)
  {
    for (int j = -SSIZE; j <= SSIZE; j++)
    {
      // TODO: include gradients
      float weight;
      float phi = M_PI * params.rot;
      float afac = 1 - params.ani;
      vec4 cov = vec4(params.sup / afac, params.sup * afac, cos(phi), sin(phi));  // needs to be replaced according to estimated gradients
      ivec2 sourcepos = ivec2(epos) + ivec2(i, j);    // position of sample
      vec2 actualsourcepos = ivec2(epos) + ivec2(i, j);   // only because offset is 0
      if (any(greaterThanEqual(sourcepos, textureSize(img, 0)))) continue;
      if (any(lessThan(sourcepos, ivec2(0, 0)))) continue;
      eval_gauss(cov, actualsourcepos - epos, weight);
      float intensity = texelFetch(img, sourcepos, 0).r;
      // acc += weight * intensity * color_vec(sourcepos);
      // wsum += 0.1 * weight * color_vec(sourcepos);
      acc += weight * intensity * color_vec(sourcepos);
      wsum += weight * color_vec(sourcepos);
    }
  }
  imageStore(acc_out, ipos, acc);
  imageStore(cont_out, ipos, wsum);


  /*
  vec4 col;
  ivec2 boff = ivec2(ipos.x%2, ipos.y%2);   // offset inside block
  ivec2 bstart = ipos - boff;
  float r = texelFetch(img, bstart, 0).r;
  float g1 = texelFetch(img, bstart + ivec2(0, 1), 0).r;
  float g2 = texelFetch(img, bstart + ivec2(1, 0), 0).r;
  float b = texelFetch(img, bstart + ivec2(1, 1), 0).r;
  if (boff == ivec2(1, 0))
  {   // green
    col = vec4(r, g2, b, 1);
  }
  else if (boff == ivec2(0, 1))
  {   // green
    col = vec4(r, g1, b, 1);
  }
  else if (boff == ivec2(0, 0))
  {   // red
    col = vec4(r, 0.5 * (g1 + g2), b, 1);
  }
  else
  {   // blue
    col = vec4(r, 0.5 * (g1 + g2), b, 1);
  }

  col.g *= 0.5;   // why is that better?
  imageStore(acc_out, ipos, col);
  imageStore(cont_out, ipos, vec4(1, 1, 1, 1));*/
}
